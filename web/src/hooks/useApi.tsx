import { toast } from "@/components/ui/use-toast";
import type { ApiTypes } from "@/gen/api";
import type { paths } from "@/gen/schema"; // generated by openapi-typescript
import { queryKeys } from "@/queryKeys";
import { useQueryClientExt } from "@/utils/use-query-client-ext";
import { queryOptions, useMutation, useQueryClient } from "@tanstack/react-query";
import createClient, { FetchResponse } from "openapi-fetch";
import { useCallback, useState } from "react";

const client = createClient<paths>({ baseUrl: location.port === "3001" ? "http://localhost:62082" : "/" });

async function handleResponse<T extends Record<string | number, any>, Options, Media extends `${string}/${string}`>(
	promise: Promise<FetchResponse<T, Options, Media>>
) {
	const response = await promise;
	if (response.error) {
		throw response.error;
	}
	return response.data;
}

export function useAddBackupGroup() {
	const queryClient = useQueryClientExt();
	return useCallback((backupGroup: ApiTypes["BackupGroup"], dbId: string) => {
		queryClient.setQueryOptionsData(queries.getServerBackups(dbId), (oldGroup) => {
			if (!oldGroup) return oldGroup;
			return [...oldGroup, backupGroup];
		});
	}, []);
}

export function useRemoveBackup() {
	const queryClient = useQueryClientExt();
	return useCallback((dbId: string, backupId: string, locationId: string) => {
		queryClient.setQueryOptionsData(queries.getServerBackups(dbId), (oldGroup) => {
			if (!oldGroup) return oldGroup;
			return oldGroup
				.map((group) => {
					if (group.backupId === backupId) {
						return {
							...group,
							backups: group.backups.filter((backup) => backup.locationId !== locationId),
						};
					}
					return group;
				})
				.filter((group) => group.backups.length > 0);
		});
	}, []);
}

export function useRefreshBackups() {
	const queryClient = useQueryClient();
	return (server: string) => {
		queryClient.invalidateQueries({ queryKey: queryKeys.serverBackup(server) });
	};
}

export function useKeepBackup() {
	const queryClient = useQueryClientExt();
	const [pendingBackups, setPendingBackups] = useState<string[]>([]);
	const updateStatus = useCallback((server: string, statuses: { [locationId: string]: ApiTypes["KeepStatus"] }, backupId: string) => {
		queryClient.setQueryOptionsData(queries.getServerBackups(server), (backupsGroups) => {
			if (!backupsGroups) return backupsGroups;
			return backupsGroups.map((group) => {
				if (group.backupId === backupId) {
					return {
						...group,
						backups: group.backups.map((backup) => {
							if (backup.locationId in statuses) {
								return {
									...backup,
									archivalStatus: statuses[backup.locationId] ?? "u",
								};
							}
							return backup;
						}),
					};
				}
				return group;
			});
		});
	}, []);
	function addPending(backupId: string) {
		setPendingBackups((backupIds) => {
			return [...backupIds, backupId];
		});
	}
	function removePending(backupId: string) {
		setPendingBackups((backupIds) => {
			return backupIds.filter((id) => id !== backupId);
		});
	}

	const keep = useMutation({
		mutationFn: async ({ dbId: dbId, backupId, locationIds }: { dbId: string; backupId: string; locationIds: string[] }) => {
			addPending(backupId);
			return await handleResponse(
				client.PUT("/db/{dbId}/backup/{backupId}/keep", { params: { path: { dbId, backupId } }, body: { locationIds } })
			);
		},
		onSuccess(result, { dbId, backupId }) {
			updateStatus(dbId, result ?? {}, backupId);
		},
		onSettled(_data, _error, { backupId }) {
			removePending(backupId);
		},
	});

	const remove = useMutation({
		mutationFn: async ({ dbId: dbId, backupId, locationIds }: { dbId: string; backupId: string; locationIds: string[] }) => {
			addPending(backupId);
			return await handleResponse(
				client.DELETE("/db/{dbId}/backup/{backupId}/keep", { params: { path: { dbId, backupId } }, body: { locationIds } })
			);
		},
		onSuccess(result, { dbId, backupId }) {
			updateStatus(dbId, result ?? {}, backupId);
		},
		onSettled(_data, _error, { backupId }) {
			removePending(backupId);
		},
	});
	return {
		keep,
		remove,
		pendingBackups,
	};
}

export function usePutArchivePolicy() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: ({ dbId, policy }: { dbId: string; policy: ApiTypes["ArchivalPolicy"] }) =>
			handleResponse(client.PUT("/db/{dbId}/archive/policy", { params: { path: { dbId } }, body: policy })),
		onSuccess(_result, { dbId, policy }) {
			queryClient.setQueryOptionsData(queries.getArchivePolicies(dbId), (oldPolicies) => {
				if (!oldPolicies) return [policy];
				return oldPolicies.filter((policy) => policy.id !== policy.id).concat(policy);
			});
			queryClient.invalidateQueries({ queryKey: queryKeys.serverBackup(dbId) });
		},
	});
}

export function usePutSettingsTimezone() {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (data: ApiTypes["PutTimezoneRequest"]) => handleResponse(client.PUT("/settings/timeZone", { body: data })),
		onSuccess(_data, timeZone) {
			queryClient.setQueryData(queryKeys.savedTimezone, timeZone);
		},
	});
}

export function useDeleteArchivePolicy() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: ({ dbId, policyId }: { dbId: string; policyId: string }) =>
			handleResponse(client.DELETE("/db/{dbId}/archive/policy/{id}", { params: { path: { dbId, id: policyId } } })),
		onSuccess(_result, { dbId, policyId }) {
			queryClient.setQueryOptionsData(queries.getArchivePolicies(dbId), (oldPolicies) => {
				if (!oldPolicies) return oldPolicies;
				return oldPolicies.filter((policy) => policy.id !== policyId);
			});
			queryClient.invalidateQueries({ queryKey: queryKeys.serverBackup(dbId) });
		},
	});
}

export function useDeleteBackupLocation() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: ({ id }: { id: string }) => handleResponse(client.DELETE("/s3/{id}", { params: { path: { id } }, body: {} })),
		onSuccess(_, { id }) {
			queryClient.setQueryOptionsData(queries.getBackupLocations(), (o) => {
				if (o) {
					const newO = {
						...o,
					};
					delete newO[id];
					return newO;
				}
				return o;
			});
		},
	});
}

export function useDeleteDatabase() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId }: { dbId: string }) => {
			return await handleResponse(client.DELETE("/db/{dbId}", { params: { path: { dbId } }, body: {} }));
		},
		onError(error) {
			toast({
				title: error.message,
				variant: "destructive",
			});
		},
		onSuccess(_, { dbId }) {
			queryClient.setQueryOptionsData(queries.getDatabases(), (old) => {
				if (old) {
					return old.filter((database) => database.id !== dbId);
				}
				return old;
			});
		},
	});
}

export function usePostBackup() {
	return useMutation({
		mutationFn: async ({ dbId, name }: { dbId: string; name?: string | null }) => {
			return await handleResponse(
				client.POST("/db/{dbId}/backup", { params: { path: { dbId }, query: { name: name ?? undefined } } })
			);
		},
	});
}

export function usePutRetention() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId, policy }: { dbId: string; policy: ApiTypes["RetentionPolicy"] }) => {
			return await handleResponse(client.PUT("/retention/{dbId}", { params: { path: { dbId } }, body: policy }));
		},
		onSuccess(_data, { dbId, policy }) {
			queryClient.setQueryOptionsData(queries.getRetention(dbId), policy);
		},
		onError() {
			toast({
				title: "Failed to update retention policy",
				variant: "destructive",
				duration: 2000,
			});
		},
	});
}

export function usePutSchedule() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId, schedule }: { dbId: string; schedule: ApiTypes["DbBackupSchedule"] }) =>
			await handleResponse(client.PUT("/db/{dbId}/schedule", { params: { path: { dbId } }, body: schedule })),
		onSuccess(_, { dbId, schedule }) {
			queryClient.setQueryOptionsData(queries.getSchedule(dbId), (old) => {
				if (!old) return old;
				return old.filter((o) => o.id !== schedule.id).concat(schedule);
			});
			toast({
				title: "Schedule Updated",
				variant: "success",
				duration: 2000,
			});
		},
		onError() {
			toast({
				title: "Failed to update schedule",
				variant: "destructive",
				duration: 2000,
			});
		},
	});
}

export function useDeleteSchedule() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId, id }: { dbId: string; id: string }) =>
			await handleResponse(client.DELETE("/db/{dbId}/schedule/{id}", { params: { path: { dbId, id } } })),
		onSuccess(_, { dbId, id }) {
			queryClient.setQueryOptionsData(queries.getSchedule(dbId), (old) => {
				if (!old) return old;
				return old.filter((o) => o.id !== id);
			});
		},
	});
}

export function useDeleteServerBackupid() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId, backupId, locationIds }: { dbId: string; backupId: string; locationIds: string[] }) =>
			await handleResponse(
				client.DELETE("/db/{dbId}/backup/{backupId}", { params: { path: { dbId, backupId } }, body: { locationIds } })
			),
		onSuccess(deletedLocations, { dbId, backupId }) {
			if (!deletedLocations) return;
			queryClient.setQueryOptionsData(queries.getServerBackups(dbId), (oldGroups) => {
				if (!oldGroups) return oldGroups;
				return oldGroups
					.map((group) => {
						if (group.backupId === backupId) {
							return {
								...group,
								backups: group.backups.filter((backup) => !deletedLocations.includes(backup.locationId)),
							};
						}
						return group;
					})
					.filter((group) => group.backups.length > 0);
			});
		},
	});
}

export function useSaveDbBackupLocations() {
	return useMutation({
		mutationFn: async ({ dbId, s3Ids }: { dbId: string; s3Ids: string[] }) =>
			await handleResponse(client.POST("/db/{dbId}/s3", { params: { path: { dbId } }, body: s3Ids })),
	});
}

export function useSaveS3() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ id, data }: { id: string; data: ApiTypes["S3BackupLocation"] }) =>
			await handleResponse(client.POST("/s3/{id}", { params: { path: { id } }, body: { config: data } })),
		onSuccess(_, { id, data }) {
			queryClient.setQueryOptionsData(queries.getBackupLocations(), (o) => {
				if (o) {
					return {
						...o,
						[id]: data,
					};
				}
				return {
					[id]: data,
				};
			});
		},
	});
}

export function useSaveDb() {
	const queryClient = useQueryClientExt();
	return useMutation({
		mutationFn: async ({ dbId, data }: { dbId: string; data: ApiTypes["DbConfig"] }) => {
			return await handleResponse(client.POST("/db/{dbId}", { params: { path: { dbId } }, body: { config: data } }));
		},
		onError(error: ApiTypes["HttpValidationProblemDetails"]) {
			toast({
				title: error.title ?? "Error adding database",
				variant: "destructive",
			});
		},
		onSuccess(database, { dbId }) {
			toast({
				title: "Database added",
				variant: "success",
			});
			if (database) {
				queryClient.setQueryOptionsData(queries.getDatabases(), (old) => {
					if (old) {
						return [...old, { id: dbId, db: database }];
					}
					return [{ id: dbId, db: database }];
				});
			}
		},
	});
}

export function getServerBackupidRecoverCmd({
	dbId,
	backupId,
	targetTime,
	s3Id,
}: {
	dbId: string;
	backupId: string;
	targetTime: string;
	s3Id: string;
}) {
	return queryOptions({
		queryKey: queryKeys.recoverCmd(dbId, backupId, targetTime),
		queryFn: async () =>
			await handleResponse(
				client.GET("/db/{dbId}/backup/{backupId}/recover/{s3Id}", {
					params: { path: { dbId, backupId, s3Id } },
					query: { targetTime },
				})
			),
	});
}

export const queries = {
	getBackupLocations() {
		return queryOptions({
			queryKey: queryKeys.backupLocations,
			queryFn: async () => await handleResponse(client.GET("/s3")),
		});
	},
	getDatabases() {
		return queryOptions({
			queryKey: ["databases"],
			queryFn: async () => await handleResponse(client.GET("/db")),
		});
	},
	getServerBackups(dbId: string) {
		return queryOptions({
			queryKey: queryKeys.serverBackup(dbId),
			queryFn: async () => await handleResponse(client.GET("/db/{dbId}/backup", { params: { path: { dbId } } })),
		});
	},
	getSchedule(dbId: string) {
		return queryOptions({
			queryKey: queryKeys.schedule(dbId),
			queryFn: async () => await handleResponse(client.GET("/db/{dbId}/schedule", { params: { path: { dbId } } })),
		});
	},
	getRetention(dbId: string) {
		return queryOptions({
			queryKey: queryKeys.retention,
			queryFn: async () => await handleResponse(client.GET("/retention/{dbId}", { params: { path: { dbId } } })),
		});
	},
	getArchivePolicies(dbId: string) {
		return queryOptions({
			queryKey: queryKeys.archivePolicy,
			queryFn: async () => await handleResponse(client.GET("/db{dbId}/archive/policies", { params: { path: { dbId } } })),
		});
	},
	getTimezones() {
		return queryOptions({
			queryKey: queryKeys.timezones,
			queryFn: async () => await handleResponse(client.GET("/timeZones")),
		});
	},
	getSavedTimezone() {
		return queryOptions({
			queryKey: queryKeys.savedTimezone,
			queryFn: async () => await handleResponse(client.GET("/settings/timeZone")),
		});
	},
	getNotifications() {
		return queryOptions({
			queryKey: queryKeys.notifications,
			queryFn: async () => await handleResponse(client.GET("/notifications")),
			refetchInterval: false,
			refetchIntervalInBackground: false,
			refetchOnMount: false,
			refetchOnReconnect: true,
			refetchOnWindowFocus: true,
		});
	},
};
